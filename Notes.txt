/*
* TODO The current SetBundle (with opengl) will not work once I implement modifying materials and or transforms with ImGui, but
* TODO if instead of storing copies of both materials and transforms, the renderers can either store pointers, or simply indices
* TODO into a global list of materials/transforms, than if they are modified there is no need to recreate the whole bundle, instead
* TODO the bundle only needs to be "re Set" when a new packet is added, or when the geometry of a packet is modified.
*
* TODO Instanced Rendering
*
* TODO Frame Time Stats
*/

   
/* // TODO Implement this:
Renderer rendereer;
// In the init function for OpenGl a GLEW instance can be made
// In the init function for Vulkan a Vulkan instance can be made
// etc...
// Before the window function is called, a GLFW instance will have been created
// The cleanup function needs to destroy the GLFW window
GLFWwindow* window = renderer.init();

renderer.setSize();
renderer.setBundle();

AddAllWindowThings(window); // Assign call backs, set up mouse movement, and key movement stuff

while (window is open) {
    GUI(); // ImGui window

    // Switch Scene
    // Switch Renderer Settings
    // Add on new items to bundle
    // Remove items from bundle
    // Modify items in bundle

    if (lastRenderer != currentRenderer) {
        disconnectAllWindowThings();

        renderer->Cleanup();

        renderer.reset();

        switch (currentRenderer) {
        case OPENGL:
            renderer = std::make_unique<OpenGlRenderer>();
            break;

        case HARD_CODED:
            renderer = std::make_unique<HardCodedRenderer>();
            break;

        case RAINBOW_TIME:
            renderer = std::make_unique<RainbowTimeRenderer>();
            break;
        }

        window = renderer->Init();

        addAllWindowThings();

        renderer->SetSize(width, height);
        renderer->SetBundle(bundle);
    }

    renderer->render();
}
*/

// Materials need to be reuploaded every frame
// Transforms need to be reuploaded every frame
    // They only need to be recalculated when they change tho
// Lights DO NOT need to be reuploaded every frame
    // But when something changes they do need to be


// Renderer changes:
// Add on a SetLight(size_t lightIndex, Light* newLight); function that sets the light at the specified index to the new light
    // This hopes that the renderer will be able to modify only one light at a time, if not a renderer could reset them all, and have
    // initialy saved a copy of the full bundle
// Add on SetPacket(size_t packetIndex, const Packet& newPacket);  same as setlight but for packets

// IF A LIGHT IS SET TO nullptr, IT IS CONSIDERD DELETED
// IF A PACKET IS SET WITH NO VERTICES, IT IS CONSIDERD DELETED

// More renderer changes:
// Add a AddLight(Light* light); function that adds on a new light onto the end of the current list of lights;
// Add a AddPacket(Packet) function that adds on a new packet to the end of the current list;

/*    
struct Packet {
    std::vector<vertices>
    std::vector<indices>

    Transform* transform

    Material* material
};

    
struct Bundle {
    std::vector<lights> lights;
    std::vector<bools> doesThisLightNeedToBeReuploaded; //DEFAULT TRUE, but set to false every time we do an upload

    std::vector<Renderable> renderables;
    std::vector<bool> doesThisRenderableNowHaveNewGeometry;
};
    */